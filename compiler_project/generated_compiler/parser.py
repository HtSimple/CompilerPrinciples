nonterminals = ['<expression_stmt>', '<decl_list>', '<local_decls>', '<param_tail>', '<id_tail>', '<decl_suffix>', '<expr_tail>', '<stmt>', '<arg_tail>', '<term_tail>', '<declaration>', '<program>', '<params>', '<expression>', '<compound_stmt>', '<mulop>', '<args>', '<param_list>', '<relop_expr>', '<term>', '<var_decl>', '<factor>', '<return_val>', '<arg_list>', '<selection_stmt>', '<iteration_stmt>', '<type_spec>', '<add_expr_tail>', '<stmt_list>', '<return_stmt>', '<additive_expression>', '<else_part>', '<relop>', '<addop>']
terminals = ['LE', 'NEQ', 'EQ', 'PLUS', 'FLOAT', 'DIV', 'STAR', 'LPAREN', 'IF', 'LBRACE', 'FLOAT_LITERAL', 'WHILE', 'GE', 'ELSE', 'ASSIGN', 'GT', 'IDENTIFIER', 'RBRACE', 'INT_LITERAL', 'RETURN', 'SEMI', 'MINUS', 'VOID', 'RPAREN', 'LT', 'COMMA', 'INT']
start_symbol = '<program>'
parse_table = {
    ('<add_expr_tail>', 'ASSIGN'): ([], ''),
    ('<add_expr_tail>', 'COMMA'): ([], ''),
    ('<add_expr_tail>', 'EQ'): ([], ''),
    ('<add_expr_tail>', 'GE'): ([], ''),
    ('<add_expr_tail>', 'GT'): ([], ''),
    ('<add_expr_tail>', 'LE'): ([], ''),
    ('<add_expr_tail>', 'LT'): ([], ''),
    ('<add_expr_tail>', 'MINUS'): (['<addop>', '<term>', '<add_expr_tail>'], ''),
    ('<add_expr_tail>', 'NEQ'): ([], ''),
    ('<add_expr_tail>', 'PLUS'): (['<addop>', '<term>', '<add_expr_tail>'], ''),
    ('<add_expr_tail>', 'RPAREN'): ([], ''),
    ('<add_expr_tail>', 'SEMI'): ([], ''),
    ('<additive_expression>', 'FLOAT_LITERAL'): (['<term>', '<add_expr_tail>'], ''),
    ('<additive_expression>', 'IDENTIFIER'): (['<term>', '<add_expr_tail>'], ''),
    ('<additive_expression>', 'INT_LITERAL'): (['<term>', '<add_expr_tail>'], ''),
    ('<additive_expression>', 'LPAREN'): (['<term>', '<add_expr_tail>'], ''),
    ('<addop>', 'MINUS'): (['MINUS'], ''),
    ('<addop>', 'PLUS'): (['PLUS'], ''),
    ('<arg_list>', 'FLOAT_LITERAL'): (['<expression>', '<arg_tail>'], ''),
    ('<arg_list>', 'IDENTIFIER'): (['<expression>', '<arg_tail>'], ''),
    ('<arg_list>', 'INT_LITERAL'): (['<expression>', '<arg_tail>'], ''),
    ('<arg_list>', 'LPAREN'): (['<expression>', '<arg_tail>'], ''),
    ('<arg_tail>', 'COMMA'): (['COMMA', '<expression>', '<arg_tail>'], ''),
    ('<arg_tail>', 'RPAREN'): ([], ''),
    ('<args>', 'FLOAT_LITERAL'): (['<arg_list>'], ''),
    ('<args>', 'IDENTIFIER'): (['<arg_list>'], ''),
    ('<args>', 'INT_LITERAL'): (['<arg_list>'], ''),
    ('<args>', 'LPAREN'): (['<arg_list>'], ''),
    ('<args>', 'RPAREN'): ([], ''),
    ('<compound_stmt>', 'LBRACE'): (['LBRACE', '<local_decls>', '<stmt_list>', 'RBRACE'], ''),
    ('<decl_list>', '$'): ([], ''),
    ('<decl_list>', 'FLOAT'): (['<declaration>', '<decl_list>'], ''),
    ('<decl_list>', 'INT'): (['<declaration>', '<decl_list>'], ''),
    ('<decl_list>', 'VOID'): (['<declaration>', '<decl_list>'], ''),
    ('<decl_suffix>', 'LPAREN'): (['LPAREN', '<params>', 'RPAREN', '<compound_stmt>'], ''),
    ('<decl_suffix>', 'SEMI'): (['SEMI'], ''),
    ('<declaration>', 'FLOAT'): (['<type_spec>', 'IDENTIFIER', '<decl_suffix>'], ''),
    ('<declaration>', 'INT'): (['<type_spec>', 'IDENTIFIER', '<decl_suffix>'], ''),
    ('<declaration>', 'VOID'): (['<type_spec>', 'IDENTIFIER', '<decl_suffix>'], ''),
    ('<else_part>', 'ELSE'): (['ELSE', '<stmt>'], ''),
    ('<else_part>', 'FLOAT_LITERAL'): ([], ''),
    ('<else_part>', 'IDENTIFIER'): ([], ''),
    ('<else_part>', 'IF'): ([], ''),
    ('<else_part>', 'INT_LITERAL'): ([], ''),
    ('<else_part>', 'LBRACE'): ([], ''),
    ('<else_part>', 'LPAREN'): ([], ''),
    ('<else_part>', 'RBRACE'): ([], ''),
    ('<else_part>', 'RETURN'): ([], ''),
    ('<else_part>', 'SEMI'): ([], ''),
    ('<else_part>', 'WHILE'): ([], ''),
    ('<expr_tail>', 'ASSIGN'): (['ASSIGN', '<expression>'], ''),
    ('<expr_tail>', 'COMMA'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'EQ'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'GE'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'GT'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'LE'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'LT'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'NEQ'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'RPAREN'): (['<relop_expr>'], ''),
    ('<expr_tail>', 'SEMI'): (['<relop_expr>'], ''),
    ('<expression>', 'FLOAT_LITERAL'): (['<additive_expression>', '<expr_tail>'], ''),
    ('<expression>', 'IDENTIFIER'): (['<additive_expression>', '<expr_tail>'], ''),
    ('<expression>', 'INT_LITERAL'): (['<additive_expression>', '<expr_tail>'], ''),
    ('<expression>', 'LPAREN'): (['<additive_expression>', '<expr_tail>'], ''),
    ('<expression_stmt>', 'FLOAT_LITERAL'): (['<expression>', 'SEMI'], ''),
    ('<expression_stmt>', 'IDENTIFIER'): (['<expression>', 'SEMI'], ''),
    ('<expression_stmt>', 'INT_LITERAL'): (['<expression>', 'SEMI'], ''),
    ('<expression_stmt>', 'LPAREN'): (['<expression>', 'SEMI'], ''),
    ('<expression_stmt>', 'SEMI'): (['SEMI'], ''),
    ('<factor>', 'FLOAT_LITERAL'): (['FLOAT_LITERAL'], ''),
    ('<factor>', 'IDENTIFIER'): (['IDENTIFIER', '<id_tail>'], ''),
    ('<factor>', 'INT_LITERAL'): (['INT_LITERAL'], ''),
    ('<factor>', 'LPAREN'): (['LPAREN', '<expression>', 'RPAREN'], ''),
    ('<id_tail>', 'ASSIGN'): ([], ''),
    ('<id_tail>', 'COMMA'): ([], ''),
    ('<id_tail>', 'DIV'): ([], ''),
    ('<id_tail>', 'EQ'): ([], ''),
    ('<id_tail>', 'GE'): ([], ''),
    ('<id_tail>', 'GT'): ([], ''),
    ('<id_tail>', 'LE'): ([], ''),
    ('<id_tail>', 'LPAREN'): (['LPAREN', '<args>', 'RPAREN'], ''),
    ('<id_tail>', 'LT'): ([], ''),
    ('<id_tail>', 'MINUS'): ([], ''),
    ('<id_tail>', 'NEQ'): ([], ''),
    ('<id_tail>', 'PLUS'): ([], ''),
    ('<id_tail>', 'RPAREN'): ([], ''),
    ('<id_tail>', 'SEMI'): ([], ''),
    ('<id_tail>', 'STAR'): ([], ''),
    ('<iteration_stmt>', 'WHILE'): (['WHILE', 'LPAREN', '<expression>', 'RPAREN', '<stmt>'], ''),
    ('<local_decls>', 'FLOAT'): (['<var_decl>', '<local_decls>'], ''),
    ('<local_decls>', 'FLOAT_LITERAL'): ([], ''),
    ('<local_decls>', 'IDENTIFIER'): ([], ''),
    ('<local_decls>', 'IF'): ([], ''),
    ('<local_decls>', 'INT'): (['<var_decl>', '<local_decls>'], ''),
    ('<local_decls>', 'INT_LITERAL'): ([], ''),
    ('<local_decls>', 'LBRACE'): ([], ''),
    ('<local_decls>', 'LPAREN'): ([], ''),
    ('<local_decls>', 'RBRACE'): ([], ''),
    ('<local_decls>', 'RETURN'): ([], ''),
    ('<local_decls>', 'SEMI'): ([], ''),
    ('<local_decls>', 'VOID'): (['<var_decl>', '<local_decls>'], ''),
    ('<local_decls>', 'WHILE'): ([], ''),
    ('<mulop>', 'DIV'): (['DIV'], ''),
    ('<mulop>', 'STAR'): (['STAR'], ''),
    ('<param_list>', 'FLOAT'): (['<type_spec>', 'IDENTIFIER', '<param_tail>'], ''),
    ('<param_list>', 'INT'): (['<type_spec>', 'IDENTIFIER', '<param_tail>'], ''),
    ('<param_list>', 'VOID'): (['<type_spec>', 'IDENTIFIER', '<param_tail>'], ''),
    ('<param_tail>', 'COMMA'): (['COMMA', '<type_spec>', 'IDENTIFIER', '<param_tail>'], ''),
    ('<param_tail>', 'RPAREN'): ([], ''),
    ('<params>', 'FLOAT'): (['<param_list>'], ''),
    ('<params>', 'INT'): (['<param_list>'], ''),
    ('<params>', 'RPAREN'): ([], ''),
    ('<params>', 'VOID'): (['<param_list>'], ''),
    ('<program>', '$'): (['<decl_list>'], ''),
    ('<program>', 'FLOAT'): (['<decl_list>'], ''),
    ('<program>', 'INT'): (['<decl_list>'], ''),
    ('<program>', 'VOID'): (['<decl_list>'], ''),
    ('<relop>', 'EQ'): (['EQ'], ''),
    ('<relop>', 'GE'): (['GE'], ''),
    ('<relop>', 'GT'): (['GT'], ''),
    ('<relop>', 'LE'): (['LE'], ''),
    ('<relop>', 'LT'): (['LT'], ''),
    ('<relop>', 'NEQ'): (['NEQ'], ''),
    ('<relop_expr>', 'COMMA'): ([], ''),
    ('<relop_expr>', 'EQ'): (['<relop>', '<additive_expression>'], ''),
    ('<relop_expr>', 'GE'): (['<relop>', '<additive_expression>'], ''),
    ('<relop_expr>', 'GT'): (['<relop>', '<additive_expression>'], ''),
    ('<relop_expr>', 'LE'): (['<relop>', '<additive_expression>'], ''),
    ('<relop_expr>', 'LT'): (['<relop>', '<additive_expression>'], ''),
    ('<relop_expr>', 'NEQ'): (['<relop>', '<additive_expression>'], ''),
    ('<relop_expr>', 'RPAREN'): ([], ''),
    ('<relop_expr>', 'SEMI'): ([], ''),
    ('<return_stmt>', 'RETURN'): (['RETURN', '<return_val>', 'SEMI'], ''),
    ('<return_val>', 'FLOAT_LITERAL'): (['<expression>'], ''),
    ('<return_val>', 'IDENTIFIER'): (['<expression>'], ''),
    ('<return_val>', 'INT_LITERAL'): (['<expression>'], ''),
    ('<return_val>', 'LPAREN'): (['<expression>'], ''),
    ('<return_val>', 'SEMI'): ([], ''),
    ('<selection_stmt>', 'IF'): (['IF', 'LPAREN', '<expression>', 'RPAREN', '<stmt>', '<else_part>'], ''),
    ('<stmt>', 'FLOAT_LITERAL'): (['<expression_stmt>'], ''),
    ('<stmt>', 'IDENTIFIER'): (['<expression_stmt>'], ''),
    ('<stmt>', 'IF'): (['<selection_stmt>'], ''),
    ('<stmt>', 'INT_LITERAL'): (['<expression_stmt>'], ''),
    ('<stmt>', 'LBRACE'): (['<compound_stmt>'], ''),
    ('<stmt>', 'LPAREN'): (['<expression_stmt>'], ''),
    ('<stmt>', 'RETURN'): (['<return_stmt>'], ''),
    ('<stmt>', 'SEMI'): (['<expression_stmt>'], ''),
    ('<stmt>', 'WHILE'): (['<iteration_stmt>'], ''),
    ('<stmt_list>', 'FLOAT_LITERAL'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'IDENTIFIER'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'IF'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'INT_LITERAL'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'LBRACE'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'LPAREN'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'RBRACE'): ([], ''),
    ('<stmt_list>', 'RETURN'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'SEMI'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'WHILE'): (['<stmt>', '<stmt_list>'], ''),
    ('<term>', 'FLOAT_LITERAL'): (['<factor>', '<term_tail>'], ''),
    ('<term>', 'IDENTIFIER'): (['<factor>', '<term_tail>'], ''),
    ('<term>', 'INT_LITERAL'): (['<factor>', '<term_tail>'], ''),
    ('<term>', 'LPAREN'): (['<factor>', '<term_tail>'], ''),
    ('<term_tail>', 'ASSIGN'): ([], ''),
    ('<term_tail>', 'COMMA'): ([], ''),
    ('<term_tail>', 'DIV'): (['<mulop>', '<factor>', '<term_tail>'], ''),
    ('<term_tail>', 'EQ'): ([], ''),
    ('<term_tail>', 'GE'): ([], ''),
    ('<term_tail>', 'GT'): ([], ''),
    ('<term_tail>', 'LE'): ([], ''),
    ('<term_tail>', 'LT'): ([], ''),
    ('<term_tail>', 'MINUS'): ([], ''),
    ('<term_tail>', 'NEQ'): ([], ''),
    ('<term_tail>', 'PLUS'): ([], ''),
    ('<term_tail>', 'RPAREN'): ([], ''),
    ('<term_tail>', 'SEMI'): ([], ''),
    ('<term_tail>', 'STAR'): (['<mulop>', '<factor>', '<term_tail>'], ''),
    ('<type_spec>', 'FLOAT'): (['FLOAT'], ''),
    ('<type_spec>', 'INT'): (['INT'], ''),
    ('<type_spec>', 'VOID'): (['VOID'], ''),
    ('<var_decl>', 'FLOAT'): (['<type_spec>', 'IDENTIFIER', 'SEMI'], ''),
    ('<var_decl>', 'INT'): (['<type_spec>', 'IDENTIFIER', 'SEMI'], ''),
    ('<var_decl>', 'VOID'): (['<type_spec>', 'IDENTIFIER', 'SEMI'], ''),
}

def parse(token_list, verbose=True):
    if not token_list or token_list[-1] != '$':
        token_list = list(token_list) + ['$']
    stack = ['$']
    stack.append(start_symbol)
    ip = 0
    while stack:
        top = stack.pop()
        lookahead = token_list[ip]
        if verbose: print(f'STACK TOP: {top}, LOOKAHEAD: {lookahead}')
        
        if top == '$': return True if lookahead == '$' else False
        
        if top not in nonterminals:
            if top == lookahead: ip += 1
            else: 
                if verbose: print(f'Error: Expected {top}, got {lookahead}')
                return False
        else:
            key = (top, lookahead)
            if key not in parse_table:
                if verbose: print(f'No table entry for {key}')
                return False
            rhs, _ = parse_table[key]
            for sym in reversed(rhs): stack.append(sym)
    return True
