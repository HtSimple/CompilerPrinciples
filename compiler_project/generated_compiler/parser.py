# Auto-generated by yacc_builder.py
# Table-driven LL(1) parser (no semantic actions)

nonterminals = ['<pure_expr_stmt>', '<stmt>', '<function_list>', '<param_list_tail>', '<assign_stmt>', '<function>', '<factor>', '<return_stmt>', '<var_decl>', '<program>', '<param_list>', '<add_expr>', '<param>', '<type>', '<if_stmt>', '<while_stmt>', '<add_tail>', '<mul_tail>', '<return_tail>', '<expr>', '<block_stmt>', '<stmt_list>', '<if_tail>', '<rel_tail>', '<mul_expr>']
terminals = ['ELSE', 'INT', 'IF', 'GE', 'SEMI', 'LBRACE', 'MULT', 'WHILE', 'SET', 'EQ', 'LPAREN', 'NUMBER', 'RPAREN', 'LE', 'ASSIGN', 'RBRACE', 'COMMA', 'PLUS', 'GT', 'RETURN', 'NE', 'IDENTIFIER', 'DIV', 'LT', 'MINUS', 'VOID']
start_symbol = '<program>'

productions = [('<program>', ['<function_list>'], None), ('<function_list>', ['<function>', '<function_list>'], None), ('<function_list>', [], None), ('<function>', ['<type>', 'IDENTIFIER', 'LPAREN', '<param_list>', 'RPAREN', 'LBRACE', '<stmt_list>', 'RBRACE'], None), ('<param_list>', ['<param>', '<param_list_tail>'], None), ('<param_list>', [], None), ('<param_list_tail>', ['COMMA', '<param>', '<param_list_tail>'], None), ('<param_list_tail>', [], None), ('<param>', ['<type>', 'IDENTIFIER'], None), ('<type>', ['INT'], None), ('<type>', ['VOID'], None), ('<stmt_list>', ['<stmt>', '<stmt_list>'], None), ('<stmt_list>', [], None), ('<stmt>', ['<var_decl>'], 'var_decl_code'), ('<stmt>', ['<assign_stmt>'], 'assign_code'), ('<stmt>', ['<if_stmt>'], 'if_code'), ('<stmt>', ['<while_stmt>'], 'while_code'), ('<stmt>', ['<return_stmt>'], 'return_code'), ('<stmt>', ['<pure_expr_stmt>'], 'expr_code'), ('<stmt>', ['<block_stmt>'], 'block_code'), ('<var_decl>', ['<type>', 'IDENTIFIER', 'SEMI'], None), ('<assign_stmt>', ['SET', 'IDENTIFIER', 'ASSIGN', '<expr>', 'SEMI'], None), ('<if_stmt>', ['IF', 'LPAREN', '<expr>', 'RPAREN', '<stmt>', '<if_tail>'], None), ('<if_tail>', ['ELSE', '<stmt>'], None), ('<if_tail>', [], None), ('<while_stmt>', ['WHILE', 'LPAREN', '<expr>', 'RPAREN', '<stmt>'], None), ('<return_stmt>', ['RETURN', '<return_tail>'], None), ('<return_tail>', ['<expr>', 'SEMI'], None), ('<return_tail>', ['SEMI'], None), ('<pure_expr_stmt>', ['<expr>', 'SEMI'], None), ('<block_stmt>', ['LBRACE', '<stmt_list>', 'RBRACE'], None), ('<expr>', ['<add_expr>', '<rel_tail>'], None), ('<rel_tail>', ['LT', '<add_expr>'], None), ('<rel_tail>', ['GT', '<add_expr>'], None), ('<rel_tail>', ['LE', '<add_expr>'], None), ('<rel_tail>', ['GE', '<add_expr>'], None), ('<rel_tail>', ['EQ', '<add_expr>'], None), ('<rel_tail>', ['NE', '<add_expr>'], None), ('<rel_tail>', [], None), ('<add_expr>', ['<mul_expr>', '<add_tail>'], None), ('<add_tail>', ['PLUS', '<mul_expr>', '<add_tail>'], None), ('<add_tail>', ['MINUS', '<mul_expr>', '<add_tail>'], None), ('<add_tail>', [], None), ('<mul_expr>', ['<factor>', '<mul_tail>'], None), ('<mul_tail>', ['MULT', '<factor>', '<mul_tail>'], None), ('<mul_tail>', ['DIV', '<factor>', '<mul_tail>'], None), ('<mul_tail>', [], None), ('<factor>', ['NUMBER'], None), ('<factor>', ['IDENTIFIER'], None), ('<factor>', ['LPAREN', '<expr>', 'RPAREN'], None)]

parse_table = {
    ('<add_expr>', 'IDENTIFIER'): (['<mul_expr>', '<add_tail>'], ''),
    ('<add_expr>', 'LPAREN'): (['<mul_expr>', '<add_tail>'], ''),
    ('<add_expr>', 'NUMBER'): (['<mul_expr>', '<add_tail>'], ''),
    ('<add_tail>', 'EQ'): ([], ''),
    ('<add_tail>', 'GE'): ([], ''),
    ('<add_tail>', 'GT'): ([], ''),
    ('<add_tail>', 'LE'): ([], ''),
    ('<add_tail>', 'LT'): ([], ''),
    ('<add_tail>', 'MINUS'): (['MINUS', '<mul_expr>', '<add_tail>'], ''),
    ('<add_tail>', 'NE'): ([], ''),
    ('<add_tail>', 'PLUS'): (['PLUS', '<mul_expr>', '<add_tail>'], ''),
    ('<add_tail>', 'RPAREN'): ([], ''),
    ('<add_tail>', 'SEMI'): ([], ''),
    ('<assign_stmt>', 'SET'): (['SET', 'IDENTIFIER', 'ASSIGN', '<expr>', 'SEMI'], ''),
    ('<block_stmt>', 'LBRACE'): (['LBRACE', '<stmt_list>', 'RBRACE'], ''),
    ('<expr>', 'IDENTIFIER'): (['<add_expr>', '<rel_tail>'], ''),
    ('<expr>', 'LPAREN'): (['<add_expr>', '<rel_tail>'], ''),
    ('<expr>', 'NUMBER'): (['<add_expr>', '<rel_tail>'], ''),
    ('<factor>', 'IDENTIFIER'): (['IDENTIFIER'], ''),
    ('<factor>', 'LPAREN'): (['LPAREN', '<expr>', 'RPAREN'], ''),
    ('<factor>', 'NUMBER'): (['NUMBER'], ''),
    ('<function>', 'INT'): (['<type>', 'IDENTIFIER', 'LPAREN', '<param_list>', 'RPAREN', 'LBRACE', '<stmt_list>', 'RBRACE'], ''),
    ('<function>', 'VOID'): (['<type>', 'IDENTIFIER', 'LPAREN', '<param_list>', 'RPAREN', 'LBRACE', '<stmt_list>', 'RBRACE'], ''),
    ('<function_list>', '$'): ([], ''),
    ('<function_list>', 'INT'): (['<function>', '<function_list>'], ''),
    ('<function_list>', 'VOID'): (['<function>', '<function_list>'], ''),
    ('<if_stmt>', 'IF'): (['IF', 'LPAREN', '<expr>', 'RPAREN', '<stmt>', '<if_tail>'], ''),
    ('<if_tail>', 'ELSE'): (['ELSE', '<stmt>'], ''),
    ('<if_tail>', 'IDENTIFIER'): ([], ''),
    ('<if_tail>', 'IF'): ([], ''),
    ('<if_tail>', 'INT'): ([], ''),
    ('<if_tail>', 'LBRACE'): ([], ''),
    ('<if_tail>', 'LPAREN'): ([], ''),
    ('<if_tail>', 'NUMBER'): ([], ''),
    ('<if_tail>', 'RBRACE'): ([], ''),
    ('<if_tail>', 'RETURN'): ([], ''),
    ('<if_tail>', 'SET'): ([], ''),
    ('<if_tail>', 'VOID'): ([], ''),
    ('<if_tail>', 'WHILE'): ([], ''),
    ('<mul_expr>', 'IDENTIFIER'): (['<factor>', '<mul_tail>'], ''),
    ('<mul_expr>', 'LPAREN'): (['<factor>', '<mul_tail>'], ''),
    ('<mul_expr>', 'NUMBER'): (['<factor>', '<mul_tail>'], ''),
    ('<mul_tail>', 'DIV'): (['DIV', '<factor>', '<mul_tail>'], ''),
    ('<mul_tail>', 'EQ'): ([], ''),
    ('<mul_tail>', 'GE'): ([], ''),
    ('<mul_tail>', 'GT'): ([], ''),
    ('<mul_tail>', 'LE'): ([], ''),
    ('<mul_tail>', 'LT'): ([], ''),
    ('<mul_tail>', 'MINUS'): ([], ''),
    ('<mul_tail>', 'MULT'): (['MULT', '<factor>', '<mul_tail>'], ''),
    ('<mul_tail>', 'NE'): ([], ''),
    ('<mul_tail>', 'PLUS'): ([], ''),
    ('<mul_tail>', 'RPAREN'): ([], ''),
    ('<mul_tail>', 'SEMI'): ([], ''),
    ('<param>', 'INT'): (['<type>', 'IDENTIFIER'], ''),
    ('<param>', 'VOID'): (['<type>', 'IDENTIFIER'], ''),
    ('<param_list>', 'INT'): (['<param>', '<param_list_tail>'], ''),
    ('<param_list>', 'RPAREN'): ([], ''),
    ('<param_list>', 'VOID'): (['<param>', '<param_list_tail>'], ''),
    ('<param_list_tail>', 'COMMA'): (['COMMA', '<param>', '<param_list_tail>'], ''),
    ('<param_list_tail>', 'RPAREN'): ([], ''),
    ('<program>', '$'): (['<function_list>'], ''),
    ('<program>', 'INT'): (['<function_list>'], ''),
    ('<program>', 'VOID'): (['<function_list>'], ''),
    ('<pure_expr_stmt>', 'IDENTIFIER'): (['<expr>', 'SEMI'], ''),
    ('<pure_expr_stmt>', 'LPAREN'): (['<expr>', 'SEMI'], ''),
    ('<pure_expr_stmt>', 'NUMBER'): (['<expr>', 'SEMI'], ''),
    ('<rel_tail>', 'EQ'): (['EQ', '<add_expr>'], ''),
    ('<rel_tail>', 'GE'): (['GE', '<add_expr>'], ''),
    ('<rel_tail>', 'GT'): (['GT', '<add_expr>'], ''),
    ('<rel_tail>', 'LE'): (['LE', '<add_expr>'], ''),
    ('<rel_tail>', 'LT'): (['LT', '<add_expr>'], ''),
    ('<rel_tail>', 'NE'): (['NE', '<add_expr>'], ''),
    ('<rel_tail>', 'RPAREN'): ([], ''),
    ('<rel_tail>', 'SEMI'): ([], ''),
    ('<return_stmt>', 'RETURN'): (['RETURN', '<return_tail>'], ''),
    ('<return_tail>', 'IDENTIFIER'): (['<expr>', 'SEMI'], ''),
    ('<return_tail>', 'LPAREN'): (['<expr>', 'SEMI'], ''),
    ('<return_tail>', 'NUMBER'): (['<expr>', 'SEMI'], ''),
    ('<return_tail>', 'SEMI'): (['SEMI'], ''),
    ('<stmt>', 'IDENTIFIER'): (['<pure_expr_stmt>'], 'expr_code'),
    ('<stmt>', 'IF'): (['<if_stmt>'], 'if_code'),
    ('<stmt>', 'INT'): (['<var_decl>'], 'var_decl_code'),
    ('<stmt>', 'LBRACE'): (['<block_stmt>'], 'block_code'),
    ('<stmt>', 'LPAREN'): (['<pure_expr_stmt>'], 'expr_code'),
    ('<stmt>', 'NUMBER'): (['<pure_expr_stmt>'], 'expr_code'),
    ('<stmt>', 'RETURN'): (['<return_stmt>'], 'return_code'),
    ('<stmt>', 'SET'): (['<assign_stmt>'], 'assign_code'),
    ('<stmt>', 'VOID'): (['<var_decl>'], 'var_decl_code'),
    ('<stmt>', 'WHILE'): (['<while_stmt>'], 'while_code'),
    ('<stmt_list>', 'IDENTIFIER'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'IF'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'INT'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'LBRACE'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'LPAREN'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'NUMBER'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'RBRACE'): ([], ''),
    ('<stmt_list>', 'RETURN'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'SET'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'VOID'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'WHILE'): (['<stmt>', '<stmt_list>'], ''),
    ('<type>', 'INT'): (['INT'], ''),
    ('<type>', 'VOID'): (['VOID'], ''),
    ('<var_decl>', 'INT'): (['<type>', 'IDENTIFIER', 'SEMI'], ''),
    ('<var_decl>', 'VOID'): (['<type>', 'IDENTIFIER', 'SEMI'], ''),
    ('<while_stmt>', 'WHILE'): (['WHILE', 'LPAREN', '<expr>', 'RPAREN', '<stmt>'], ''),
}


def parse(token_list, verbose=True):
    if not token_list or token_list[-1] != '$':
        token_list = list(token_list) + ['$']
    stack = ['$']
    stack.append(start_symbol)
    ip = 0
    while stack:
        top = stack.pop()
        lookahead = token_list[ip]
        if verbose:
            print(f'STACK TOP: {top}, LOOKAHEAD: {lookahead}')
        # 处理终结符或结束符
        if top == '$' or top not in nonterminals:
            if top == lookahead:
                ip += 1
                if top == '$':
                    return True
                continue
            else:
                if verbose:
                    print(f'Unexpected token: expected {top}, got {lookahead}')
                return False
        # 处理非终结符
        key = (top, lookahead)
        entry = parse_table.get(key)
        if entry is None:
            if verbose:
                print(f'No table entry for {key}. Syntax error.')
            return False
        right, _tag = entry
        # 反向压栈
        for sym in reversed(right):
            stack.append(sym)
    return True


# ===== 注入动作与 TAC =====
from src.runtime.ctx import TACContext
from src.runtime.token import Node
TACGEN = TACContext()

def program(children):
    node = Node("program", children)
    # 输出 TAC：使用当前作用域的 TACGEN（注入到 parser.py 时，parser 将有自己的 TACGEN）
    # 直接调用 save，save 会创建目录并写入文件
    TACGEN.save(TAC_OUTPUT_FILE)
    return node


def function(children):
    node = Node("function", children)
    if children:
        # children 的结构取决于 parser，尽量使用 str() 兼容 token / node
        func_name = str(children[1]) if len(children) > 1 else "anonymous"
        TACGEN.emit("FUNC_BEGIN", func_name)
    return node


def var_decl_code(children):
    node = Node("var_decl", children)
    if children:
        var_name = str(children[1]) if len(children) > 1 else str(children[0])
        TACGEN.emit("VAR_DECL", var_name)
    return node


def assign_code(children):
    node = Node("assign", children)
    # 典型 children: [IDENTIFIER, expr_node_or_token]
    if len(children) >= 2:
        left = str(children[0])
        right = str(children[1])
        # 目前保持与现有 emit 调用兼容：emit(op, arg1, arg2, result)
        # 如果你后续希望用 "result = arg1 op arg2"，可以把 result 传入
        TACGEN.emit("ASSIGN", left, right)
    return node


def if_code(children):
    node = Node("if", children)
    TACGEN.emit("IF", str(children))
    return node


def while_code(children):
    node = Node("while", children)
    TACGEN.emit("WHILE", str(children))
    return node


def return_code(children):
    node = Node("return", children)
    if children:
        TACGEN.emit("RETURN", str(children[0]))
    return node


def expr_code(children):
    node = Node("expr", children)
    TACGEN.emit("EXPR", str(children))
    return node


def block_code(children):
    node = Node("block", children)
    TACGEN.emit("BLOCK", str(children))
    return node


def add(children):
    node = Node("add", children)
    if len(children) == 2:
        TACGEN.emit("ADD", str(children[0]), str(children[1]))
    return node


def sub(children):
    node = Node("sub", children)
    if len(children) == 2:
        TACGEN.emit("SUB", str(children[0]), str(children[1]))
    return node


def mul(children):
    node = Node("mul", children)
    if len(children) == 2:
        TACGEN.emit("MUL", str(children[0]), str(children[1]))
    return node


def div(children):
    node = Node("div", children)
    if len(children) == 2:
        TACGEN.emit("DIV", str(children[0]), str(children[1]))
    return node


ACTIONS = {
    'program': program,
    'function': function,
    'var_decl_code': var_decl_code,
    'assign_code': assign_code,
    'if_code': if_code,
    'while_code': while_code,
    'return_code': return_code,
    'expr_code': expr_code,
    'block_code': block_code,
    'add': add,
    'sub': sub,
    'mul': mul,
    'div': div,
}


def parse_with_actions(token_list, verbose=True):
    from generated_compiler import temp_parser as tp
    # 使用原 parse() 构建的栈结构（简单驱动）
    stack = ['$']
    stack.append(tp.start_symbol)
    stack_nodes = []
    ip = 0
    while stack:
        top = stack.pop()
        lookahead = token_list[ip]
        if top == '$' or top not in tp.nonterminals:
            if top == lookahead:
                stack_nodes.append(lookahead)
                ip += 1
                if top == '$':
                    return True
                continue
            else:
                return False
        else:
            key = (top, lookahead)
            entry = tp.parse_table.get(key)
            if entry is None:
                return False
            left, right, action = entry
            for sym in reversed(right):
                stack.append(sym)
            if action:
                # pop children (终结符/非终结符都有对应的 stack_nodes 项)
                children = [stack_nodes.pop() for _ in right][::-1]
                node = ACTIONS[action](children)
                stack_nodes.append(node)
    return True

EXPORT_TAC = TACGEN
