# Auto-generated by yacc_builder.py
# Table-driven LL(1) parser (no semantic actions)

nonterminals = ['<pure_expr_stmt>', '<stmt>', '<function_list>', '<param_list_tail>', '<assign_stmt>', '<function>', '<factor>', '<return_stmt>', '<var_decl>', '<program>', '<param_list>', '<add_expr>', '<param>', '<type>', '<if_stmt>', '<while_stmt>', '<add_tail>', '<mul_tail>', '<return_tail>', '<expr>', '<block_stmt>', '<stmt_list>', '<if_tail>', '<rel_tail>', '<mul_expr>']
terminals = ['ELSE', 'INT', 'IF', 'GE', 'SEMI', 'LBRACE', 'MULT', 'WHILE', 'SET', 'EQ', 'LPAREN', 'NUMBER', 'RPAREN', 'LE', 'ASSIGN', 'RBRACE', 'COMMA', 'PLUS', 'GT', 'RETURN', 'NE', 'IDENTIFIER', 'DIV', 'LT', 'MINUS', 'VOID']
start_symbol = '<program>'

productions = [('<program>', ['<function_list>'], None), ('<function_list>', ['<function>', '<function_list>'], None), ('<function_list>', [], None), ('<function>', ['<type>', 'IDENTIFIER', 'LPAREN', '<param_list>', 'RPAREN', 'LBRACE', '<stmt_list>', 'RBRACE'], None), ('<param_list>', ['<param>', '<param_list_tail>'], None), ('<param_list>', [], None), ('<param_list_tail>', ['COMMA', '<param>', '<param_list_tail>'], None), ('<param_list_tail>', [], None), ('<param>', ['<type>', 'IDENTIFIER'], None), ('<type>', ['INT'], None), ('<type>', ['VOID'], None), ('<stmt_list>', ['<stmt>', '<stmt_list>'], None), ('<stmt_list>', [], None), ('<stmt>', ['<var_decl>'], 'var_decl_code'), ('<stmt>', ['<assign_stmt>'], 'assign_code'), ('<stmt>', ['<if_stmt>'], 'if_code'), ('<stmt>', ['<while_stmt>'], 'while_code'), ('<stmt>', ['<return_stmt>'], 'return_code'), ('<stmt>', ['<pure_expr_stmt>'], 'expr_code'), ('<stmt>', ['<block_stmt>'], 'block_code'), ('<var_decl>', ['<type>', 'IDENTIFIER', 'SEMI'], None), ('<assign_stmt>', ['SET', 'IDENTIFIER', 'ASSIGN', '<expr>', 'SEMI'], None), ('<if_stmt>', ['IF', 'LPAREN', '<expr>', 'RPAREN', '<stmt>', '<if_tail>'], None), ('<if_tail>', ['ELSE', '<stmt>'], None), ('<if_tail>', [], None), ('<while_stmt>', ['WHILE', 'LPAREN', '<expr>', 'RPAREN', '<stmt>'], None), ('<return_stmt>', ['RETURN', '<return_tail>'], None), ('<return_tail>', ['<expr>', 'SEMI'], None), ('<return_tail>', ['SEMI'], None), ('<pure_expr_stmt>', ['<expr>', 'SEMI'], None), ('<block_stmt>', ['LBRACE', '<stmt_list>', 'RBRACE'], None), ('<expr>', ['<add_expr>', '<rel_tail>'], None), ('<rel_tail>', ['LT', '<add_expr>'], None), ('<rel_tail>', ['GT', '<add_expr>'], None), ('<rel_tail>', ['LE', '<add_expr>'], None), ('<rel_tail>', ['GE', '<add_expr>'], None), ('<rel_tail>', ['EQ', '<add_expr>'], None), ('<rel_tail>', ['NE', '<add_expr>'], None), ('<rel_tail>', [], None), ('<add_expr>', ['<mul_expr>', '<add_tail>'], None), ('<add_tail>', ['PLUS', '<mul_expr>', '<add_tail>'], None), ('<add_tail>', ['MINUS', '<mul_expr>', '<add_tail>'], None), ('<add_tail>', [], None), ('<mul_expr>', ['<factor>', '<mul_tail>'], None), ('<mul_tail>', ['MULT', '<factor>', '<mul_tail>'], None), ('<mul_tail>', ['DIV', '<factor>', '<mul_tail>'], None), ('<mul_tail>', [], None), ('<factor>', ['NUMBER'], None), ('<factor>', ['IDENTIFIER'], None), ('<factor>', ['LPAREN', '<expr>', 'RPAREN'], None)]

parse_table = {
    ('<add_expr>', 'IDENTIFIER'): (['<mul_expr>', '<add_tail>'], ''),
    ('<add_expr>', 'LPAREN'): (['<mul_expr>', '<add_tail>'], ''),
    ('<add_expr>', 'NUMBER'): (['<mul_expr>', '<add_tail>'], ''),
    ('<add_tail>', 'EQ'): ([], ''),
    ('<add_tail>', 'GE'): ([], ''),
    ('<add_tail>', 'GT'): ([], ''),
    ('<add_tail>', 'LE'): ([], ''),
    ('<add_tail>', 'LT'): ([], ''),
    ('<add_tail>', 'MINUS'): (['MINUS', '<mul_expr>', '<add_tail>'], ''),
    ('<add_tail>', 'NE'): ([], ''),
    ('<add_tail>', 'PLUS'): (['PLUS', '<mul_expr>', '<add_tail>'], ''),
    ('<add_tail>', 'RPAREN'): ([], ''),
    ('<add_tail>', 'SEMI'): ([], ''),
    ('<assign_stmt>', 'SET'): (['SET', 'IDENTIFIER', 'ASSIGN', '<expr>', 'SEMI'], ''),
    ('<block_stmt>', 'LBRACE'): (['LBRACE', '<stmt_list>', 'RBRACE'], ''),
    ('<expr>', 'IDENTIFIER'): (['<add_expr>', '<rel_tail>'], ''),
    ('<expr>', 'LPAREN'): (['<add_expr>', '<rel_tail>'], ''),
    ('<expr>', 'NUMBER'): (['<add_expr>', '<rel_tail>'], ''),
    ('<factor>', 'IDENTIFIER'): (['IDENTIFIER'], ''),
    ('<factor>', 'LPAREN'): (['LPAREN', '<expr>', 'RPAREN'], ''),
    ('<factor>', 'NUMBER'): (['NUMBER'], ''),
    ('<function>', 'INT'): (['<type>', 'IDENTIFIER', 'LPAREN', '<param_list>', 'RPAREN', 'LBRACE', '<stmt_list>', 'RBRACE'], ''),
    ('<function>', 'VOID'): (['<type>', 'IDENTIFIER', 'LPAREN', '<param_list>', 'RPAREN', 'LBRACE', '<stmt_list>', 'RBRACE'], ''),
    ('<function_list>', '$'): ([], ''),
    ('<function_list>', 'INT'): (['<function>', '<function_list>'], ''),
    ('<function_list>', 'VOID'): (['<function>', '<function_list>'], ''),
    ('<if_stmt>', 'IF'): (['IF', 'LPAREN', '<expr>', 'RPAREN', '<stmt>', '<if_tail>'], ''),
    ('<if_tail>', 'ELSE'): (['ELSE', '<stmt>'], ''),
    ('<if_tail>', 'IDENTIFIER'): ([], ''),
    ('<if_tail>', 'IF'): ([], ''),
    ('<if_tail>', 'INT'): ([], ''),
    ('<if_tail>', 'LBRACE'): ([], ''),
    ('<if_tail>', 'LPAREN'): ([], ''),
    ('<if_tail>', 'NUMBER'): ([], ''),
    ('<if_tail>', 'RBRACE'): ([], ''),
    ('<if_tail>', 'RETURN'): ([], ''),
    ('<if_tail>', 'SET'): ([], ''),
    ('<if_tail>', 'VOID'): ([], ''),
    ('<if_tail>', 'WHILE'): ([], ''),
    ('<mul_expr>', 'IDENTIFIER'): (['<factor>', '<mul_tail>'], ''),
    ('<mul_expr>', 'LPAREN'): (['<factor>', '<mul_tail>'], ''),
    ('<mul_expr>', 'NUMBER'): (['<factor>', '<mul_tail>'], ''),
    ('<mul_tail>', 'DIV'): (['DIV', '<factor>', '<mul_tail>'], ''),
    ('<mul_tail>', 'EQ'): ([], ''),
    ('<mul_tail>', 'GE'): ([], ''),
    ('<mul_tail>', 'GT'): ([], ''),
    ('<mul_tail>', 'LE'): ([], ''),
    ('<mul_tail>', 'LT'): ([], ''),
    ('<mul_tail>', 'MINUS'): ([], ''),
    ('<mul_tail>', 'MULT'): (['MULT', '<factor>', '<mul_tail>'], ''),
    ('<mul_tail>', 'NE'): ([], ''),
    ('<mul_tail>', 'PLUS'): ([], ''),
    ('<mul_tail>', 'RPAREN'): ([], ''),
    ('<mul_tail>', 'SEMI'): ([], ''),
    ('<param>', 'INT'): (['<type>', 'IDENTIFIER'], ''),
    ('<param>', 'VOID'): (['<type>', 'IDENTIFIER'], ''),
    ('<param_list>', 'INT'): (['<param>', '<param_list_tail>'], ''),
    ('<param_list>', 'RPAREN'): ([], ''),
    ('<param_list>', 'VOID'): (['<param>', '<param_list_tail>'], ''),
    ('<param_list_tail>', 'COMMA'): (['COMMA', '<param>', '<param_list_tail>'], ''),
    ('<param_list_tail>', 'RPAREN'): ([], ''),
    ('<program>', '$'): (['<function_list>'], ''),
    ('<program>', 'INT'): (['<function_list>'], ''),
    ('<program>', 'VOID'): (['<function_list>'], ''),
    ('<pure_expr_stmt>', 'IDENTIFIER'): (['<expr>', 'SEMI'], ''),
    ('<pure_expr_stmt>', 'LPAREN'): (['<expr>', 'SEMI'], ''),
    ('<pure_expr_stmt>', 'NUMBER'): (['<expr>', 'SEMI'], ''),
    ('<rel_tail>', 'EQ'): (['EQ', '<add_expr>'], ''),
    ('<rel_tail>', 'GE'): (['GE', '<add_expr>'], ''),
    ('<rel_tail>', 'GT'): (['GT', '<add_expr>'], ''),
    ('<rel_tail>', 'LE'): (['LE', '<add_expr>'], ''),
    ('<rel_tail>', 'LT'): (['LT', '<add_expr>'], ''),
    ('<rel_tail>', 'NE'): (['NE', '<add_expr>'], ''),
    ('<rel_tail>', 'RPAREN'): ([], ''),
    ('<rel_tail>', 'SEMI'): ([], ''),
    ('<return_stmt>', 'RETURN'): (['RETURN', '<return_tail>'], ''),
    ('<return_tail>', 'IDENTIFIER'): (['<expr>', 'SEMI'], ''),
    ('<return_tail>', 'LPAREN'): (['<expr>', 'SEMI'], ''),
    ('<return_tail>', 'NUMBER'): (['<expr>', 'SEMI'], ''),
    ('<return_tail>', 'SEMI'): (['SEMI'], ''),
    ('<stmt>', 'IDENTIFIER'): (['<pure_expr_stmt>'], 'expr_code'),
    ('<stmt>', 'IF'): (['<if_stmt>'], 'if_code'),
    ('<stmt>', 'INT'): (['<var_decl>'], 'var_decl_code'),
    ('<stmt>', 'LBRACE'): (['<block_stmt>'], 'block_code'),
    ('<stmt>', 'LPAREN'): (['<pure_expr_stmt>'], 'expr_code'),
    ('<stmt>', 'NUMBER'): (['<pure_expr_stmt>'], 'expr_code'),
    ('<stmt>', 'RETURN'): (['<return_stmt>'], 'return_code'),
    ('<stmt>', 'SET'): (['<assign_stmt>'], 'assign_code'),
    ('<stmt>', 'VOID'): (['<var_decl>'], 'var_decl_code'),
    ('<stmt>', 'WHILE'): (['<while_stmt>'], 'while_code'),
    ('<stmt_list>', 'IDENTIFIER'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'IF'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'INT'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'LBRACE'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'LPAREN'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'NUMBER'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'RBRACE'): ([], ''),
    ('<stmt_list>', 'RETURN'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'SET'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'VOID'): (['<stmt>', '<stmt_list>'], ''),
    ('<stmt_list>', 'WHILE'): (['<stmt>', '<stmt_list>'], ''),
    ('<type>', 'INT'): (['INT'], ''),
    ('<type>', 'VOID'): (['VOID'], ''),
    ('<var_decl>', 'INT'): (['<type>', 'IDENTIFIER', 'SEMI'], ''),
    ('<var_decl>', 'VOID'): (['<type>', 'IDENTIFIER', 'SEMI'], ''),
    ('<while_stmt>', 'WHILE'): (['WHILE', 'LPAREN', '<expr>', 'RPAREN', '<stmt>'], ''),
}


def parse(token_list, verbose=True):
    if not token_list or token_list[-1] != '$':
        token_list = list(token_list) + ['$']
    stack = ['$']
    stack.append(start_symbol)
    ip = 0
    while stack:
        top = stack.pop()
        lookahead = token_list[ip]
        if verbose:
            print(f'STACK TOP: {top}, LOOKAHEAD: {lookahead}')
        # 处理终结符或结束符
        if top == '$' or top not in nonterminals:
            if top == lookahead:
                ip += 1
                if top == '$':
                    return True
                continue
            else:
                if verbose:
                    print(f'Unexpected token: expected {top}, got {lookahead}')
                return False
        # 处理非终结符
        key = (top, lookahead)
        entry = parse_table.get(key)
        if entry is None:
            if verbose:
                print(f'No table entry for {key}. Syntax error.')
            return False
        right, _tag = entry
        # 反向压栈
        for sym in reversed(right):
            stack.append(sym)
    return True
