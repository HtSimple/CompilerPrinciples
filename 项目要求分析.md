# 编译原理期末项目要求分析

## 要求分析(AI)

该期末项目要求以最多 4 人团队形式，构建一个 “编译器的编译器”，需实现词法 / 语法分析器自动生成及指定语言中间代码生成，通过 Canvas 提交多类材料并参与现场答辩，最终按功能实现、展示等多维度评分。

### 一、核心目标与能力要求

- 掌握编译器自动构造的经典算法，理解编译原理核心技术与编程方法。
- 提升系统开发全流程能力，涵盖需求分析、算法设计、编码及文档编写。
- 锻炼文献研究、开源资源利用、团队协作、表达展示及批判性思维。

### 二、核心任务要求

1. **技术选型**：从指定经典算法中选择实现，词法分析可选汤普森构造法等，语法分析可选 LL (1) 或 LR 分析法，中间代码生成需基于属性文法或语法制导翻译。
2. **功能实现**：编译器的编译器需接收词法规则（如正则文法）和语法规则（如上下文无关文法），自动生成对应语言的词法 / 语法分析器；至少支持一种测试语言的中间代码生成，生成的编译器需能处理源程序、输出三地址码等中间代码，并对错误代码报错。
3. **开发规范**：代码需托管在 GitHub 或 Gitee，通过提交记录等体现团队协作与个人贡献；中间代码生成需与语法分析同步进行，采用语法制导翻译并保存到文件。

### 三、团队与提交要求

- 团队规模：最多 4 人，项目权重占总成绩 30%。
- 提交材料：包括源代码（压缩为 ZIP）、程序设计文档（Word/PDF）、答辩 PPT，需通过 Canvas 提交（每队仅需一次提交）。
- 开源要求：代码需上传至 GitHub/Gitee，README 需包含项目介绍、测试用例设计及测试结果，测试需覆盖 “编译器的编译器本身” 和 “生成编译器的功能” 两类场景。

### 四、文档与 PPT 规范

#### 程序设计文档

- 核心内容：系统设计（概述 + 详细设计）、系统实现（功能描述 + 关键代码截图）、系统测试（用例设计 + 结果，需保证完整性和挑战性）、AI 辅助工具使用说明。
- 格式要求：逻辑清晰、详略得当、格式专业。

#### 答辩 PPT

- 核心内容：系统功能概述、测试用例介绍、团队协作展示（GitHub/Gitee 相关记录）、系统演示。

### 五、展示与评分规则

#### 展示安排

- 时间：第 16 周，按团队编号顺序进行；展示 10 分钟（全员必须参加），问答 5 分钟。
- 注意事项：提前在教室测试电脑，确保 PPT 和程序正常运行；展示前需完成 Canvas 材料提交。

#### 评分标准（总分 100%）

- 功能实现（正确性、完整性、创新性等）：50%
- 展示质量：20%
- 文档质量：10%
- 代码仓库公开情况：10%
- 团队协作：10%

### 六、参考资源

- 编译器工具参考：ANTLR、BISON (YACC)、FLEX (LEX)。
- 编程语言定义参考：PL/0、Decaf。
- 规则格式：词法规则常用正则表达式，语法规则常用乔姆斯基上下文无关文法或巴科斯 - 诺尔范式（BNF）。



## 具体实现(暂定，待商讨)

语言选择：Python

分工：
张昊天--词法分析部分代码+程序设计文档编写  
夏弘泰--语法分析部分代码+代码汇总+答辩PPT制作  
陈帆--中间代码生成部分代码+测试案例设计+答辩汇报(不确定，答辩说是全员参加，但不知道汇报要几个人讲)

参考项目结构：

```plaintext
compiler_project/
├── generator/               # 编译器生成器（3人共同目标）
│   ├── lex_builder.py       # A：NFA/DFA 构造器
│   ├── yacc_builder.py      # B：FIRST/FOLLOW，LL(1)/LR 表构造
│   ├── action_builder.py    # C：语义动作注入（生成 parser.py）
│   └── generator_main.py    # 主入口：依次运行 A→B→C
│
├── generated_compiler/      # 最终生成的“目标编译器”
│   ├── lexer.py             # A 的最终产物（由 lex_builder 自动生成）
│   ├── temp_parser.py       # B 的产物（无语义动作，仅语法分析）
│   ├── parser.py            # C 的产物（最终 parser，含 SDT 生成 TAC）
│   └── tac_output.txt       # 中间代码输出文件（parser.py 运行后自动生成）
│
├── config/
│   ├── lex_rules.lex        # 词法规则（正则）
│   └── yacc_rules.bnf       # 语法规则 + 语义动作标签（不包含 python 代码）
│
├── src/
│   ├── runtime/
│   │   ├── token.py         # Token 数据结构（供 Lexer 使用）
│   │   └── ctx.py           # 中间代码生成上下文（place, type, emit 等）
│   ├── test_driver.py       # 用于运行 generated_compiler
│   └── main.py              # 运行 A→B→C，生成目标编译器
│
├── test/                    # 测试语言源代码（如 PL/0，Mini-Decaf）
├── docs/
└── README.md
```

规定：数据格式等见api_spec.md文件



####  三人分工总览（A：词法，B：语法，C：中间代码/语义动作）

| 人员              | 职责                                                   | 负责目录                                             | 最终产出                                                     |
| ----------------- | ------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| **A（词法） **    | 构造 NFA→DFA→最小化 DFA，生成 `lexer.py`               | `generator/lex_builder.py`，`config/lex_rules.lex`   | 自动生成的 `generated_compiler/lexer.py`                     |
| **B（语法）**     | FIRST/FOLLOW，构造 LL(1)/LR(1)，生成 parser 框架       | `generator/yacc_builder.py`，`config/yacc_rules.bnf` | 自动生成的 `generated_compiler/temp_parser.py`（无语义动作代码） |
| **C（中间代码）** | 语义动作框架、TAC 生成、context 管理、最终 parser 合成 | `generator/action_builder.py`, `src/runtime/ctx.py`  | 生成generated_compiler/parser.py，输出 `tac_output.txt`      |

负责具体文件：

**A（词法）**

```
generator/lex_builder.py
config/lex_rules.lex
generated_compiler/lexer.py (自动生成)
```

**B（语法）**

```
generator/yacc_builder.py
config/yacc_rules.bnf
generated_compiler/temp_parser.py (自动生成，无语义动作)
```

**C（语义动作 & 中间代码）**

```
src/runtime/ctx.py
generator/action_builder.py
generated_compiler/parser.py (最终含语义动作，自动生成)
generated_compiler/tac_output.txt
```


